<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NEMU PA2 菜鸡记录</title>
    <link href="/2021/09/30/NEMU_PA2/"/>
    <url>/2021/09/30/NEMU_PA2/</url>
    
    <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<del>端地一番折磨</del>  </p><p>本篇博客由PA1实验报告改编而来，后续可能会有必做题的过程<del>也可能没有</del>  </p><p> <del>看阿瓜的懒惰程度了</del></p><h1 id="实验进度表"><a href="#实验进度表" class="headerlink" title="实验进度表"></a><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>运行用户程序mov.c</td><td>已完成</td></tr><tr><td>必做任务2</td><td>实现更多指令</td><td>已完成</td></tr><tr><td>必做任务3</td><td>实现binary scaling</td><td>已完成</td></tr><tr><td>必做任务4</td><td>为表达式求值添加变量的支持</td><td>已完成</td></tr><tr><td>必做任务5</td><td>实现loader</td><td>已完成</td></tr><tr><td>选做任务1</td><td>打印栈帧链</td><td>已完成</td></tr><tr><td>选做任务2</td><td>改变程序的行为</td><td>未完成</td></tr></tbody></table><h1 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a><strong>必做题</strong></h1><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a><strong>思考题</strong></h1><h2 id="思考题1：main函数返回到哪里"><a href="#思考题1：main函数返回到哪里" class="headerlink" title="思考题1：main函数返回到哪里"></a>思考题1：main函数返回到哪里</h2><ul><li>在testcase里的测试文件中，程序从start函数里跳转到main函数，main函数执行完毕后再返回到start里。所以HIT GOOD TRAP 一般都在0x100014处</li></ul><h2 id="思考题2：比较FLOAT和float"><a href="#思考题2：比较FLOAT和float" class="headerlink" title="思考题2：比较FLOAT和float"></a>思考题2：比较FLOAT和float</h2><ul><li>其区别首先在于FLOAT是定点数而float是浮点数，作为浮点数，float对于规格化的值与非规格化的值两种情况其阶码值和尾数的计算公式并不一样，这就使得其可以比较精确地表示0和非常接近于0的数以及非常大的数。而FLOAT由于定点化，在牺牲表数范围和精度的同时换取了速度。</li></ul><h2 id="思考题3：消失的符号"><a href="#思考题3：消失的符号" class="headerlink" title="思考题3：消失的符号"></a>思考题3：消失的符号</h2><ul><li>符号表symtab中包含的符号有三类：1.非静态的c函数和全局变量;2.其他模块中定义的非静态c函数和全局变量;3.只在该模块中定义和引用的带static属性的C函数和全局变量。<br>对于非静态的局部变量则在栈中管理，并不被symtab包含</li></ul><h2 id="思考题4：堆和栈在哪里"><a href="#思考题4：堆和栈在哪里" class="headerlink" title="思考题4：堆和栈在哪里"></a>思考题4：堆和栈在哪里</h2><ul><li>堆和栈的数据存取比较频繁，如果放入可执行文件可能导致运行速度下降。程序执行时，再从内部调用堆和栈。</li></ul><h2 id="思考题5：如何识别不同格式的可执行文件"><a href="#思考题5：如何识别不同格式的可执行文件" class="headerlink" title="思考题5：如何识别不同格式的可执行文件"></a>思考题5：如何识别不同格式的可执行文件</h2><ul><li>ELF文件头有魔数，可以用做识别文件格式。<h2 id="思考题6：冗余的属性"><a href="#思考题6：冗余的属性" class="headerlink" title="思考题6：冗余的属性"></a>思考题6：冗余的属性</h2></li><li>FileSiz表示程序头在文件中所占的大小，MemSiz表示程序头在内存中所占用的大小。</li></ul><h1 id="实验遇到的问题、思考、解决办法"><a href="#实验遇到的问题、思考、解决办法" class="headerlink" title="实验遇到的问题、思考、解决办法"></a>实验遇到的问题、思考、解决办法</h1><ul><li>对于必做任务三的FLOAT.c中的f2F函数实现曾出现过错误，然后修改过后仍hit bad trap，然后make clean之后再make run便可以运行。当时不知道make clean的原理，误以为f2F函数并没有错误，故又恢复原貌，导致提交的前一版stage2_finished不能通过integral.c测试。然后多次测试后发现FLOAT.c文件在修改后并不会重新编译，除非make clean。经助教齐学长讲解，明白了FLOAT.c生成的是动态链接库，不是可重定向目标文件，所以make clean之后才会重新编译。故最后修改正确之后补交了一版stage2_finished_new。  </li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>ELF头文件前几个数是为魔数（magic number），用做识别文件类型之用。</li><li>HIT BAD TRAP一般可能是三种错误，<ul><li>1.exec.c文件里opcode表填写错误，比如某条指令形式应为rm2r误写成r2rm；</li><li>2,.指令的具体实现出现错误，例如jcc系列指令的条件判断写错或者call、ret、push、pop、leave等指令的ebp、esp寄存器相关内容出错;</li><li>3.FLOAT函数具体实现出错。 </li></ul></li><li>需要写的程序不一定只在TODO标明的地方，其临近处或者其他地方也可能根据需要而添加或者修改代码  </li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA3 菜鸡记录</title>
    <link href="/2021/09/28/NEMU_PA3/"/>
    <url>/2021/09/28/NEMU_PA3/</url>
    
    <content type="html"><![CDATA[<h1 id="实验进度表"><a href="#实验进度表" class="headerlink" title="实验进度表"></a><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>实现一级Cache</td><td>已完成</td></tr><tr><td>必做任务2</td><td>在NEMU中实现分段机制</td><td>已完成</td></tr><tr><td>必做任务3</td><td>在NEMU中实现分页机制</td><td>已完成</td></tr><tr><td>必做任务4</td><td>实现TLB</td><td>已完成</td></tr><tr><td>选做任务1</td><td>实现二级Cache</td><td>已完成</td></tr><tr><td>选做任务2</td><td>建议调试器</td><td>未完成</td></tr><tr><td>选做任务3</td><td>为用户进程创建video memory 映射</td><td>未完成</td></tr></tbody></table><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a><strong>思考题</strong></h1><h2 id="思考题1：GDT能有多大"><a href="#思考题1：GDT能有多大" class="headerlink" title="思考题1：GDT能有多大"></a>思考题1：GDT能有多大</h2><ul><li>段选择符的结构中，INDEX有13位，故GDT最大能容纳2^13个段描述符  </li></ul><h2 id="思考题2：为什么是线性地址"><a href="#思考题2：为什么是线性地址" class="headerlink" title="思考题2：为什么是线性地址"></a>思考题2：为什么是线性地址</h2><ul><li>不可以。虚拟地址需要经GDT中的段表翻译才能得出地址，而如果GDTR中存放虚拟地址则找不到GDT在哪里了。  </li></ul><h2 id="思考题3：如何提高寻找段描述符的效率"><a href="#思考题3：如何提高寻找段描述符的效率" class="headerlink" title="思考题3：如何提高寻找段描述符的效率"></a>思考题3：如何提高寻找段描述符的效率</h2><ul><li>可以按照高速缓存的思想，建立类似cache 和 TLB 的结构来提高寻找效率。  </li></ul><h2 id="思考题4：段式存储管理的缺点"><a href="#思考题4：段式存储管理的缺点" class="headerlink" title="思考题4：段式存储管理的缺点"></a>思考题4：段式存储管理的缺点</h2><ul><li>分段管理要求分配一大段连续的存储空间，难以实现并且容易造成大量的外部碎片出现。  </li></ul><h2 id="思考题5：页式存储管理的优点"><a href="#思考题5：页式存储管理的优点" class="headerlink" title="思考题5：页式存储管理的优点"></a>思考题5：页式存储管理的优点</h2><ul><li>没有外部碎片，并且不再需要大段连续的存储空间，提高了内存的利用率。  </li></ul><h2 id="思考题6：一些问题"><a href="#思考题6：一些问题" class="headerlink" title="思考题6：一些问题"></a>思考题6：一些问题</h2><ol><li><ul><li>Q：为什么页表表项中的基地址信息只有20位而不是32位</li><li>A：分页基地址有20位是8086的传统<br>  在8086的分段机制中，每个段的基地址由seg_reg（即段寄存器的值）&lt;&lt;4得到，而段寄存器是16位的，左移4位得到20位的基地址。  </li></ul></li><li><ul><li>Q：表项和CR3中的基地址都是物理地址，这是必须的吗？能否采用虚拟地址或者线性地址？  </li><li>A：是必须的，如果cr3中的基地址是虚拟地址，则无从寻找页表翻译成物理地址，进入鸡生蛋蛋生鸡的死循环。至于其他表项的虚拟地址与线性地址问题同理。</li></ul></li><li><ul><li>Q：为什么不采用一级页表？采用一级页表会有什么缺点？  </li><li>A：多级页表可以有效地节约内存空间，如果仅采用一级页表，将可能导致较大的页表长期驻留在内存中。  </li></ul></li></ol><h2 id="思考题7：空指针是“空”的吗"><a href="#思考题7：空指针是“空”的吗" class="headerlink" title="思考题7：空指针是“空”的吗"></a>思考题7：空指针是“空”的吗</h2><ul><li>空指针只是未分配或者未指向内存任何位置的指针，并不是“NULL”的。</li></ul><h2 id="思考题8：在扁平模式下如何进行保护"><a href="#思考题8：在扁平模式下如何进行保护" class="headerlink" title="思考题8：在扁平模式下如何进行保护"></a>思考题8：在扁平模式下如何进行保护</h2><ul><li>对于数据有不同的访问权限，未达到需要的权限时不能进行写操作。  </li></ul><h2 id="思考题9：地址映射"><a href="#思考题9：地址映射" class="headerlink" title="思考题9：地址映射"></a>思考题9：地址映射</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/%E6%80%9D%E8%80%83%E9%A2%989.png" alt="思考题9" title="思考题9">  </p><h2 id="思考题10："><a href="#思考题10：" class="headerlink" title="思考题10："></a>思考题10：</h2><ul><li>pframe_addr是无符号类型，它的值永远大于等于0，所以for循环无法退出，出现错误。 </li></ul><h2 id="思考题11：分页机制"><a href="#思考题11：分页机制" class="headerlink" title="思考题11：分页机制"></a>思考题11：分页机制</h2><ol><li><ul><li>因为这里定义的ｘ生成的地址是虚拟地址，超过了物理地址的界限，报错0xc014a000 outside of the physical memory。<br>而ｋvm.c 中的虚拟地址都经过了 va_to_pa 的转换，在物理地址范围之内。  </li></ul></li><li><ul><li>进行反汇编后，其地址如下：<br>c01003d6:    e8 65 09 00 00           call   c0100d40<init_page>   该call指令的opcode为e8，实现的是跳转到：该条指令的下一条指令的首地址+偏移量的位置。由于未进行寻址，故不需要进行虚实地址转化。</li></ul></li><li><ul><li>分页的环境下，在没有初始化页表时，0～128M的虚拟地址到物理地址的映射相当于一个简易的页表，使得高位的地址可以通过该虚拟地址（即经过va_to_pa）访问到物理地址，从而进行初始化页表的操作。  </li></ul></li><li><ul><li>init_mm()函数执行退出时。该函数将nemu映射到了高位地址并且将之前的PDE全部置为无效，此时返回main.c时，栈中保存的返回地址需要经过虚实转换，可由于页面被置为了无效，所以报错。  </li></ul></li><li><ul><li>查看汇编代码，直接调用此函数时，nemu运行在物理地址上，由于在init_mm中将之前的PDE都置为无效，所以在loader()函数寻址时页面无效，导致报错。 </li></ul></li></ol><h1 id="实验遇到的问题、思考、解决办法"><a href="#实验遇到的问题、思考、解决办法" class="headerlink" title="实验遇到的问题、思考、解决办法"></a>实验遇到的问题、思考、解决办法</h1><ul><li><p>对GDT一直看不很明白，以为数组的元素大小也需要跟处理器位数一样，最大是32位，实际上GDT的元素就是64位的段描述符，不过是分成了两个32位的结构体</p></li><li><p>由于初始时对分段很不理解，然后对指导书内容进行了相应的整理，如下：</p><ul><li><p>由于内存的增长，单纯段寄存器无法满足寻址需要，需要采用分段机制。  </p></li><li><p>80386作为32位处理器，故提供的指针都是32位的，而段寄存器只有16位，而段描述符有64位，用指针存储也无法做到。故采用GDT（Global Descriptor Table, 全局描述符表）来存储段描述符。  </p></li><li><p>GDT是一个数组，数组元素是64位的段描述符（实际上是一个有两个32位member的结构体）而数组下标则由段寄存器的前13位得到（最后两位用来描述优先级，中间1位TI用来判断是GDT还是LDT）（GDT是全局描述符表，而LDT是每个进程的描述符表，由于分页机制的出现，LDT并不需要在NEMU中实现）  </p></li><li><p>CPU还需要记录GDT的基地址，这通过设置一个GDTR的寄存器来实现，该寄存器有48位，前32位类似于指针存放GDT的首地址，后16位记录GDT的长度  </p></li></ul></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>指针最大位数受CPU位数影响，所以才需要GDT进行段描述符的存储和读取</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA1 菜鸡记录</title>
    <link href="/2021/09/21/NEMU_PA1/"/>
    <url>/2021/09/21/NEMU_PA1/</url>
    
    <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<del>端地一番折磨</del>  </p><p>本篇博客由PA1实验报告改编而来，后续可能会有必做题的过程<del>也可能没有</del>  </p><p> <del>看阿瓜的懒惰程度了</del></p><h1 id="实验进度表"><a href="#实验进度表" class="headerlink" title="实验进度表"></a><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>实现正确的寄存器结构体</td><td>已完成</td></tr><tr><td>必做任务2</td><td>实现单步执行、打印寄存器、扫描内存</td><td>已完成</td></tr><tr><td>必做任务3</td><td>实现算术表达式的词法分析</td><td>已完成</td></tr><tr><td>必做任务4</td><td>实现算术表达式的递归求值</td><td>已完成</td></tr><tr><td>选做任务1</td><td>实现带有负数的算术表达式的求值</td><td>已完成</td></tr><tr><td>必做任务5</td><td>实现更复杂的表达式求值</td><td>已完成</td></tr><tr><td>选做任务2</td><td>实现指针解引用</td><td>已完成</td></tr><tr><td>必做任务6</td><td>实现监视点池的管理</td><td>已完成</td></tr><tr><td>必做任务7</td><td>实现监视点</td><td>已完成</td></tr></tbody></table><h1 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a><strong>必做题</strong></h1><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a><strong>思考题</strong></h1><h2 id="思考题1-：opcode-table数组的类型"><a href="#思考题1-：opcode-table数组的类型" class="headerlink" title="思考题1 ：opcode_table数组的类型"></a>思考题1 ：opcode_table数组的类型</h2><ul><li>opcode_table为helper_fun类型的数组，而helper_fun类型为指向参数类型为swaddr_t且返回值类型为int的函数指针，故opcode_table为函数指针数组。  </li></ul><h2 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h2><h3 id="（1）要执行多久"><a href="#（1）要执行多久" class="headerlink" title="（1）要执行多久"></a>（1）要执行多久</h3><ul><li>cpu_exec函数的参数是uint32_t，即无符号整型，而传入的-1因会导致溢出而成为最大的无符号整型数，保证能够执行完输入的所有指令。  </li></ul><h3 id="（2）为什么要使用static"><a href="#（2）为什么要使用static" class="headerlink" title="（2）为什么要使用static"></a>（2）为什么要使用static</h3><ul><li><p>Q：框架代码中定义 wp_pool 等变量的时候使用了关键字 static，static 在此处的含义是什么? 为什么要在此处使用它?  </p></li><li><p>A： static表示wp_pool为静态全局变量，此处使用static是为了避免wp_pool在程序运行中被误修改。  </p></li></ul><h2 id="思考题3：读手册的方法"><a href="#思考题3：读手册的方法" class="headerlink" title="思考题3：读手册的方法"></a>思考题3：读手册的方法</h2><ol><li><ul><li>Q： EFLAGS 寄存器中的 CF 位是什么意思  </li><li>A: 在目录中检索register和flag发现2.3.4.1节和附录c有提及相关内容，查阅得：CF为进位标志，如果运算导致最高位产生进位或者借位则为1.否则为0。  </li></ul></li><li><ul><li>Q: ModR/M 字节是什么</li><li>A: 检索目录得ModR/M相关内容在17.2.1节，查阅可知ModR/M字节包括mod、reg、r/m三方面内容,分别表示索引类型或者寄存器编号、寻址模式编码等信息。  </li></ul></li><li><ul><li>Q: mov 指令的具体格式是怎么样的</li><li>A: 检索目录在12.2.2.11节内找到mov指令相关内容，查阅可知格式为DEST←SRC  </li></ul></li><li><ul><li>shell命令:<br>  find . -name “*[.h|.cpp]” | xargs wc -l<br>  使用上述命令，得代码共129281行    </li></ul></li><li><ul><li><p>Make文件：  </p><p>  -Wall 使GCC产生尽可能多的警告信息，取消编译操作，打印出编译时所有错误或警告信息。  </p><p>  -Werror 要求GCC将所有的警告当成错误进行处理，从而终止编译操作。  </p><p>  使用-Wall和-Werror就是为了找出所有存在的或者潜在的错误，优化程序。</p></li></ul></li></ol><h1 id="实验遇到的问题、思考、解决办法"><a href="#实验遇到的问题、思考、解决办法" class="headerlink" title="实验遇到的问题、思考、解决办法"></a>实验遇到的问题、思考、解决办法</h1><ul><li><p>在刚开始实验的时候，遇到“Makefile : “run”……”这种错误会不知所措，Prof Wei指点我要慢慢debug，通过Log、Assert等函数以及GDB等工具，最终解决了bug。<del>（GDB过于生疏，PA1完全靠肉眼debug）</del>  </p></li><li><p>某次在虚仿平台关机导致git文件损坏，csdn、stackoverflow搜索到的办法都未能解决问题，最终在Wei老师的帮助下通过删除然后重新绑定远程仓库解决了问题。  </p></li><li><p>打印寄存器时起初不知道如何依次打印，后来发现reg.h文件下有定义好的regsl数组和reg_l函数可以利用。  </p></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li><p> 要细读实验指导书，里面内容很详细，开始时候因为只看PPT导致忽略掉了很多细节内容。</p></li><li><p>调试程序时要善于使用gdb等工具，小型的bug可以使用Log、Assert等函数两面夹击来判断bug出现在哪里，总之对bug不要失措.</p></li><li><p>对于某任务中所用到的文件中的代码要通读一下，不求全看懂，多少知道相关函数、数组是做什么的，比如reg.h文件下的regsl数组和reg_l函数，</p></li><li><p>在.c文件中声明函数后要在.h文件中定义</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/21/hello-world/"/>
    <url>/2021/09/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>The First One</title>
    <link href="/2021/07/03/The-First-One/"/>
    <url>/2021/07/03/The-First-One/</url>
    
    <content type="html"><![CDATA[<p>这是王珣的第一篇博客，自然要题写几个大字</p><p>hello, world!  </p><p><img src="https://raw.githubusercontent.com/zcsryu2/BlogImages/main/hello_world_movie.jpg" alt="这是图片" title="hello world"><br>（划掉）</p><p><img src="https://raw.githubusercontent.com/zcsryu2/BlogImages/main/hello_world.jpg" alt="这是图片" title="hello, world"></p><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲话</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
