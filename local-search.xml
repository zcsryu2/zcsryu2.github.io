<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/11/10/%E8%BF%9B%E7%A8%8B%E4%B9%A0%E9%A2%98/"/>
    <url>/2021/11/10/%E8%BF%9B%E7%A8%8B%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>若某单处理器多进程系统中有多个就绪态进程，在进程处于临界区时能否进行处理机调度？  <ul><li> 可以，当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的。比如，通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机时，不能处理机调度，那么系统的性能将是非常低的。  </li><li>几种不适合进行处理机调度的情况：①在处理中断的过程中；②进程在操作系统内核程序临界区中；③其他需要完全屏蔽中断的原子操作过程中。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6.S081 lab1 Xv6_utilities</title>
    <link href="/2021/10/20/6.S081_lab1/"/>
    <url>/2021/10/20/6.S081_lab1/</url>
    
    <content type="html"><![CDATA[<p>pipe结构如下  </p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#define PIPESIZE 512struct pipe &#123;  struct spinlock lock;  char data[PIPESIZE];  uint nread;     &#x2F;&#x2F; number of bytes read  uint nwrite;    &#x2F;&#x2F; number of bytes written  int readopen;   &#x2F;&#x2F; read fd is still open  int writeopen;  &#x2F;&#x2F; write fd is still open&#125;;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>在pipe(fd)后，fd[2]数组已不再是一般的有两个元素的int型数组，调用write函数写入fd[1]中的数据都会传到管道并存入缓冲区</p><h1 id="1-Sleep函数"><a href="#1-Sleep函数" class="headerlink" title="1.    Sleep函数"></a><strong>1.    Sleep函数</strong></h1><h2 id="（1）-实验目的"><a href="#（1）-实验目的" class="headerlink" title="（1）    实验目的"></a>（1）    实验目的</h2><p>实现一条指令，使xv6可以暂停相应参数的ticks（tick为xv6的一个时间单位），输入格式为sleep 10。  </p><h2 id="（2）-实验步骤"><a href="#（2）-实验步骤" class="headerlink" title="（2）    实验步骤"></a>（2）    实验步骤</h2><p>要求在user/sleep.c中实现，故新建sleep.c文件。在user.h文件中有可以调用的函数，根据要求，此处只需要根据输入格式“sleep 第一个参数”调用atoi函数和sleep函数，第一个参数为sleep的ticks。由于是按char*格式传入的参数，需要调用atoi函数来转换成int型参量。</p><h2 id="（3）-实验代码"><a href="#（3）-实验代码" class="headerlink" title="（3）    实验代码"></a>（3）    实验代码</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;sleep fuction#include &quot;kernel&#x2F;types.h&quot;#include &quot;user&#x2F;user.h&quot;int atoi(const char *s);void main(int argc, char *argv[])&#123;    if(argc &#x3D;&#x3D; 1)        printf(&quot;Error! Please input the number of ticks.\n&quot;);    else if(argc &#x3D;&#x3D; 2)&#123;        int num;        num &#x3D; atoi(argv[1]);        sleep(num);    &#125;    else&#123;        printf(&quot;Error! You input too much argument or no argument.\n&quot;);    &#125;    exit(0);&#125;&#96;&#96;&#96;   # **2.Pingpong函数**## （1）实验目的在进程之间创建管道实现通信，使父进程向子进程发送ping，如果接收成功则子进程输出“&lt;pid&gt;: received ping”，子进程向父进程发送png，如果接收成功则父进程输出“&lt;pid&gt;: received pong”。’## （2）实验步骤Pipe函数定义如下 分别建立两个有两个元素的int型数组fd_pa[2]和fd_ch[2]作为父进程和子进程之间通信的管道，其中[0]用于读取，[1]用于写入。Pipe函数调用由于fork( )在子进程中返回值为0，而在父进程中返回值为子进程的pid（大于0），则可以由此区分情况，分别调用write( )和read( )进行写入和读取即可。输出时要求输出相应进程的pid，调用getpid( )即可。  此处子进程中应当先read到fd_pa之中的“ping”之后再向fa_ch进行write，不然出现奇怪的bug。  ## （3）实验代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>//pingpong fuction<br>#include “kernel/types.h”<br>#include “user/user.h”<br>// #include “kernel/pipe.c”</p><p>void main(int argc, char* argv){<br>    int fd_pa[2], fd_ch[2];//written by parent and child<br>    char buf[5];<br>    if(pipe(fd_pa) == -1 || pipe(fd_ch) == -1){<br>        printf(“Fail to create pipe\n”);<br>    }<br>    if(fork() &gt; 0){<br>        write(fd_pa[1], “ping”, strlen(“ping”));<br>        read(fd_ch[0], buf, strlen(“pong”));<br>        printf(“%d: received %s\n”, getpid(), buf);<br>    }<br>    else if(fork() == 0){<br>        read(fd_pa[0], buf, strlen(“ping”));<br>        printf(“%d: received %s\n”, getpid(), buf);<br>        write(fd_ch[1], “pong”, strlen(“ping”));<br>    }<br>    else if(fork() == -1){<br>        printf(“Fail to create process\n”);<br>    }<br>    exit(0);<br>}</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"> # **3.Primes函数**## （1）实验目的通过pipe( ) 和fork( )来设置管道，以实现埃氏筛法来寻找不大于35的素数,输入为”primes”## （2）实验步骤![筛法](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;zcsryu2&#x2F;Blog_images&#x2F;main&#x2F;pipe.jpg &quot;埃氏筛法&quot;)  思路即如图所示，每一次选取管道中第一个数作为base，剩下的数如果可以整除base则被筛掉，余下的数进行下一次筛，直到只剩下一个数。每次的base即为筛得的质数。  ![pipe](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;zcsryu2&#x2F;Blog_images&#x2F;main&#x2F;pipe_struct.jpg &quot;pipe结构体&quot;)  首先将大于等于2且小于等于35的整数输入管道中（在调用pipe函数之后，fd实际是形成了一个pipe的结构，写入fd[1]的数据实际会以char型写入data中），然后关闭写入端，防止不同进程之间同时写入。子进程中，调用read( )读取base之后（read函数读取过的数据会被自动从data中删除掉），对管道中剩下的数分别进行检验，筛掉合数，对剩下的不能整除base的数作为新的数组调用prime函数，递归直到只剩1个数，最终即得所有的质数。本实验中，对于各进程需要注意wait(0)的位置，不然可能会导致某一进程提前结束进而导致shell的$符随机出现并因此无法通过测试。## （3）实验代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>//primes fuction<br>#include “kernel/types.h”<br>#include “user/user.h”</p><p>int num = 35;</p><p>//埃氏筛法寻找质数<br>void primes(int *array, int num){<br>    if(num == 1){<br>        printf(“prime %d\n”, *array);<br>        return ;<br>    }<br>    int fd[2];<br>    if(pipe(fd) == -1){<br>        printf(“Fail to create pipe\n”);<br>        return ;<br>    }<br>    int base, temp;<br>    base = *array;<br>    printf(“prime %d\n”, base);</p><div class="code-wrapper"><pre><code>if(fork() == 0)&#123;    int i;    for(i = 0; i &lt; num; ++i)&#123;        temp = array[i];        write(fd[1], &amp;temp, sizeof(int));    &#125;    exit(0);&#125;close(fd[1]);if(fork() == 0)&#123;    int ans = 0;    while(read(fd[0], &amp;temp, sizeof(int)) != 0)&#123;        //每读出一段数据，被读出的数据会被从pipe中清除        if(temp % base != 0)&#123;            *array = temp;            array += 1;            ans++;        &#125;    &#125;    primes(array - ans, ans);    wait(0);    exit(0);&#125;wait(0);</code></pre></div><p>}</p><p>void main(int argc, char* argv){<br>    int array[num - 1];;<br>    int i;<br>    for(i = 0; i &lt; num - 1; ++i){<br>        array[i] = i + 2;<br>    }<br>    primes(array, num - 1);<br>    wait(0);<br>    exit(0);<br>}</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"> # **4.Find函数**## （1）实验目的在指定路径及其子文件夹内寻找指定名称的文件，格式为<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>find <path> <filename></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">## （2）实验步骤题目中提示查看user&#x2F;ls.c来了解怎样读取目录，发现ls.c实现的功能和题目要求的很相似，只缺少对文件名称进行比对后输出这一功能，故先将ls.c的代码copy至find.c中之后进行修改即可。Ls.c的代码中，调用open( )获取相应的文件描述符并输入fd，调用fstat( )函数是st得到相应的文件属性，如果是文件，则输出，如果是文件夹，则在路径后加’&#x2F;’和该文件夹下的文件名或者文件夹名，再调用该函数。具体修改如下：在st.type是文件而不是文件夹的时候，调用strcmp函数对该文件的文件名与寻找的filename进行对比，如果一样则输出（此处需要先调用fmtname( )将路径名转化为文件名）。题目要求不输出“.”和“..”，故当de.name是“.”和“..”时，跳过## （3）实验代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>//find fuction<br>#include “kernel/types.h”<br>#include “user/user.h”<br>#include “kernel/stat.h”<br>#include “kernel/fs.h”</p><p>char* fmtname(char *path){<br>    static char buf[DIRSIZ + 1];<br>    char *p;</p><div class="code-wrapper"><pre><code>// Find first character after last slash.for(p = path + strlen(path); p &gt;= path &amp;&amp; *p != &#39;/&#39;; p--);p++;// Return blank-padded name.if(strlen(p) &gt;= DIRSIZ)    return p;memmove(buf, p, strlen(p) + 1);// memset(buf + strlen(p), &#39; &#39;, DIRSIZ - strlen(p));return buf;</code></pre></div><p>}</p><p>void find(char <em>path, char</em> filename){<br>    char buf[512], *p;<br>    int fd;<br>    struct dirent de;<br>    struct stat st;</p><div class="code-wrapper"><pre><code>if((fd = open(path, 0)) &lt; 0)&#123;    fprintf(2, &quot;find: cannot open %s\n&quot;, path);    return;&#125;if(fstat(fd, &amp;st) &lt; 0)&#123;    fprintf(2, &quot;find: cannot stat %s\n&quot;, path);    close(fd);    return;&#125;switch(st.type)&#123;case T_FILE:    // printf(&quot;%s %d %d %l\n&quot;, fmtname(path), st.type, st.ino, st.size);    if(strcmp(fmtname(path), filename) == 0)&#123;        printf(&quot;%s\n&quot;, path);    &#125;    break;case T_DIR:    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;        printf(&quot;ls: path too long\n&quot;);        break;    &#125;    strcpy(buf, path);    p = buf + strlen(buf);    *p++ = &#39;/&#39;;    while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123;        if(de.inum == 0 || strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0)            continue;        memmove(p, de.name, DIRSIZ);        p[DIRSIZ] = 0;        if(stat(buf, &amp;st) &lt; 0)&#123;            printf(&quot;ls: cannot stat %s\n&quot;, buf);            continue;        &#125;        // printf(&quot;%s %d %d %d\n&quot;, fmtname(buf), st.type, st.ino, st.size);        find(buf, filename);    &#125;break;&#125;close(fd);</code></pre></div><p>}</p><p>void main(int argc, char* argv[]){<br>    if(argc != 3){<br>        printf(“Error! You input too much argument or no argument.\n”);<br>        exit(0);<br>    }<br>    find(argv[1], argv[2]);<br>    exit(0);<br>}</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"> # **5.xargs函数**## （1）实验目的在xv6中实现xargs指令，使前一条指令的输出由标准输入转化为命令行参数来作为后面指令的参数（之一）。此处要求实现的xargs指令前只有一个参数。## （2）实验步骤 ![xrags](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;zcsryu2&#x2F;Blog_images&#x2F;main&#x2F;xrags.jpg &quot;xrags指令样例&quot;) 以上图为例，如果一个指令以这样的形式输入命令行，则‘|’前的输出”hello too”会被存在0（缓冲区）中。实现xargs时，只需要在其后指令（echo）的参数后缀上前面的输出，即从0中read出来并作为最后一个参数即可。然后调用fork ( )创建子进程并调用exec( )来执行“xargs”其后的指令即可。## （3）实验代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>#include “kernel/types.h”<br>#include “kernel/stat.h”<br>#include “user/user.h”<br>#include “kernel/fs.h”<br>#include “kernel/param.h”</p><p>void main(int argc, char *argv[]) {<br>    if(argc &lt; 2) {<br>        printf(“Error! You input too few arguments.\n”);<br>        exit(0);<br>    }<br>    if(argc + 1 &gt; MAXARG) {<br>        printf(“Error! You input too many arguments.\n”);<br>        exit(0);<br>    }<br>    char *command = argv[1];<br>    char *argument[MAXARG], buf[512];<br>    int i;</p><div class="code-wrapper"><pre><code>for (i = 1; i &lt; argc; i++) &#123;    argument[i - 1] = argv[i];&#125;argument[argc] = 0;while(1) &#123;    i = 0;    while(1) &#123;        int n = read(0, &amp;buf[i], 1);        if(n == 0 || buf[i] == &#39;\n&#39;)             break;        i++;    &#125;    if(i == 0)         break;    buf[i] = 0;    argument[argc - 1] = buf;    if(fork() == 0) &#123;        exec(command, argument);        exit(0);    &#125;     else&#123;        wait(0);    &#125;&#125;exit(0);</code></pre></div><p>}</p><div class="code-wrapper"><pre><code></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资本的限度读书笔记</title>
    <link href="/2021/10/17/%E8%B5%84%E6%9C%AC%E7%9A%84%E9%99%90%E5%BA%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/17/%E8%B5%84%E6%9C%AC%E7%9A%84%E9%99%90%E5%BA%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="重印版序言"><a href="#重印版序言" class="headerlink" title="重印版序言"></a>重印版序言</h2><p>此序言在最前，故从此开始。  </p><p>出版于八十年代的原版很多预言已经应验，新自由主义席卷下的今天，资本主义及其阶级愈发以极小的人数比例占有极大比例的财富，并且在七十年代以来其统治愈发巩固。  </p><p>何以无大规模的革命出现呢？一部分是群众之间日益碎片化，大家意见不再一致于社会主义革命；再者，新自由主义的规训使人们相信新自由主义可以带来其说的一般的福祉以及自己切身所处为自由，此种壁垒森严的思想铁壁使得各地人们趋向于在新自由主义规定好的议题下进行“抗争”（落入彀中矣）</p>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Marxism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程</title>
    <link href="/2021/10/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>多线程编程</p><p>Linux提供的pthread库只允许向线程里传入一个参数，如果想传入多个参数，需要用结构体或者指针</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>该程序借助pthread线程库实现了多线程的快速排序，随机建立N个元素的int型数组，然后八线程地进行快速排序，然后对各线程的排序结果进行归并，并输出归并后的数组。<br>为检验实现的多线程快速排序的准确性，最后对原数组进行冒泡排序并输出排序后数组，两相对比可知。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plaintext"><figcaption><span><pthread.h></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs #include">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>//多线程分开进行快排，最后对各线程快排结果进行归并<br>//const int N = 1e3;<br>#define N 100<br>const int NR_CPU = 8;<br>// int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;<br>int arr[N];<br><br>typedef struct&#123;<br>    int* n;<br>    int start, end;<br>&#125;param_t;<br><br>void swap(int *x, int *y)&#123;<br>    int t = *x;<br>    *x = *y;<br>    *y = t;<br>&#125;<br><br>void quick_sort_recursive(int arr[], int start, int end)&#123;<br>    if(start &gt;= end)&#123;<br>        return;<br>    &#125;<br>    int mid = arr[end];<br>    int left = start, right = end - 1;<br>    while(left &lt; right)&#123;<br>        while (arr[left] &lt; mid &amp;&amp; left &lt; right)<br>            left++;<br>        while (arr[right] &gt;= mid &amp;&amp; left &lt; right)<br>            right--;<br>        swap(&amp;arr[left], &amp;arr[right]);<br>    &#125;<br>    if(arr[left] &gt;= arr[end])<br>        swap(&amp;arr[left], &amp;arr[end]);<br>    else<br>        left++;<br>    if(left)&#123;<br>        quick_sort_recursive(arr, start, left - 1);<br>    &#125;<br>    quick_sort_recursive(arr, left + 1, end);<br>&#125;<br><br>void quick_sort(int arr[], int len)&#123;<br>    quick_sort_recursive(arr, 0, len - 1);<br>&#125;<br><br>void* runner(void *args)&#123;<br>    param_t *p = (param_t *)args;<br>    quick_sort_recursive(arr, p-&gt;start, p-&gt;end);<br>    int i = 0;<br>    // for(i = p-&gt;start; i &lt;= p-&gt;end; ++i)&#123;<br>    //     printf(&quot;%d &quot;, arr[i]);<br>    // &#125;<br>    // printf(&quot;\n&quot;);<br>&#125;<br><br>void merge(const int *n, int start, int mid, int end)&#123;<br>    int *p = malloc(sizeof(int) * (end - start));<br>    const int *p1 = n + start, *p2 = n + mid;<br>    int len1 = mid - start, len2 = end - mid;<br>    int idx = 0, i = 0, j = 0;<br>    while (i &lt; len1 &amp;&amp; j &lt; len2)&#123;<br>        if (p1[i] &lt; p2[j]) p[idx++] = p1[i++];<br>        else p[idx++] = p2[j++];<br>    &#125;<br>    while (i &lt; len1) p[idx++] = p1[i++];<br>    while (j &lt; len2) p[idx++] = p2[j++];<br>    memcpy((void *)(n + start), (void *)p, sizeof(int) * idx);<br>&#125;<br><br>int main()&#123;<br>    srand(time(NULL));<br>    int i = 0;<br>    for (; i &lt; N; ++i)&#123;<br>        arr[i] = random() % N;<br>    &#125;<br>    // int N = (int) sizeof(arr) / sizeof(*arr);<br>    printf(&quot;%d\n&quot;,N);<br>    int step = N / NR_CPU;<br>    param_t params[NR_CPU];<br>    pthread_t pids[NR_CPU];<br>    // int i = 0;<br>    for (i = 0; i &lt; NR_CPU; ++i)&#123;<br>        pids[i] = 0;<br>        params[i].n = arr;<br>        params[i].start = i * step;<br>        params[i].end = params[i].start + step-1;<br>    &#125;<br>    params[NR_CPU - 1].end = N;<br>    for (i = 0; i &lt; NR_CPU; i++)&#123;<br>        pthread_create(&amp;pids[i], NULL, runner, &amp;params[i]);<br>    &#125;<br>    for (i = 0; i &lt; NR_CPU; ++i)&#123;<br>        pthread_join(pids[i], NULL);<br>    &#125;<br>    while (step &lt; N)&#123;<br>        int start = 0;<br>        while (start &lt; N)&#123;<br>            int mid = start + step;<br>            int end = mid + step;<br>            if (mid &gt; N) mid = N;<br>            if (end &gt; N) end = N;<br>            merge(arr, start, mid, end);<br>            start = end;<br>        &#125;<br>        step *= 2;<br>    &#125;<br>    for (i = 0; i &lt; N; i++)<br>        printf(&quot;%d &quot;, arr[i]);<br>            printf(&quot;\n&quot;);<br>    int j;<br>    for(i = 0; i &lt; N; ++i)&#123;<br>        for(j = i; j &lt; N; ++j)&#123;<br>            if(arr[i] &gt; arr[j])&#123;<br>                int temp = arr[i];<br>                arr[i] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>        for (i = 0; i &lt; N; i++)<br>        printf(&quot;%d &quot;, arr[i]);<br>    printf(&quot;\n&quot;);<br><br>    return 0;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>创建新线程时,利用pthread_create函数，该函数原型如下：<br>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);<br>其中，参数thread用于缓存新线程的pid， 参数attr是新线程的线程属性，可以事先设置也可以缺省，第三个参数是函数指针，是新线程的运行的函数，本程序中是runner，参数arg是向新线程中传入的参数。<br>可以看到，通过pthread_create函数只能向新线程传入1个参数，这时一般通过结构体来达到传入多个参数的目的。<br>为防止各进程未执行完毕main函数就执行到输出数组，在print之前应用pthread_join函数来等待线程结束。在本程序中，线程在执行完runner函数之后自动终止。<br>多线程编程似乎一般用于各线程之间功能相似的程序，最后在主线程里需要进行汇总或者归并。</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA2 菜鸡记录</title>
    <link href="/2021/09/30/NEMU_PA2/"/>
    <url>/2021/09/30/NEMU_PA2/</url>
    
    <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<del>端地一番折磨</del>  </p><p>本篇博客由PA2实验报告改编而来，后续可能会有必做题的过程<del>也可能没有</del>  </p><p> <del>看阿瓜的懒惰程度了</del></p><h1 id="实验进度表"><a href="#实验进度表" class="headerlink" title="实验进度表"></a><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>运行用户程序mov.c</td><td>已完成</td></tr><tr><td>必做任务2</td><td>实现更多指令</td><td>已完成</td></tr><tr><td>必做任务3</td><td>实现binary scaling</td><td>已完成</td></tr><tr><td>必做任务4</td><td>为表达式求值添加变量的支持</td><td>已完成</td></tr><tr><td>必做任务5</td><td>实现loader</td><td>已完成</td></tr><tr><td>选做任务1</td><td>打印栈帧链</td><td>已完成</td></tr><tr><td>选做任务2</td><td>改变程序的行为</td><td>未完成</td></tr></tbody></table><h1 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a><strong>必做题</strong></h1><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a><strong>思考题</strong></h1><h2 id="思考题1：main函数返回到哪里"><a href="#思考题1：main函数返回到哪里" class="headerlink" title="思考题1：main函数返回到哪里"></a>思考题1：main函数返回到哪里</h2><ul><li>在testcase里的测试文件中，程序从start函数里跳转到main函数，main函数执行完毕后再返回到start里。所以HIT GOOD TRAP 一般都在0x100014处</li></ul><h2 id="思考题2：比较FLOAT和float"><a href="#思考题2：比较FLOAT和float" class="headerlink" title="思考题2：比较FLOAT和float"></a>思考题2：比较FLOAT和float</h2><ul><li>其区别首先在于FLOAT是定点数而float是浮点数，作为浮点数，float对于规格化的值与非规格化的值两种情况其阶码值和尾数的计算公式并不一样，这就使得其可以比较精确地表示0和非常接近于0的数以及非常大的数。而FLOAT由于定点化，在牺牲表数范围和精度的同时换取了速度。</li></ul><h2 id="思考题3：消失的符号"><a href="#思考题3：消失的符号" class="headerlink" title="思考题3：消失的符号"></a>思考题3：消失的符号</h2><ul><li>符号表symtab中包含的符号有三类：1.非静态的c函数和全局变量;2.其他模块中定义的非静态c函数和全局变量;3.只在该模块中定义和引用的带static属性的C函数和全局变量。<br>对于非静态的局部变量则在栈中管理，并不被symtab包含</li></ul><h2 id="思考题4：堆和栈在哪里"><a href="#思考题4：堆和栈在哪里" class="headerlink" title="思考题4：堆和栈在哪里"></a>思考题4：堆和栈在哪里</h2><ul><li>堆和栈的数据存取比较频繁，如果放入可执行文件可能导致运行速度下降。程序执行时，再从内部调用堆和栈。</li></ul><h2 id="思考题5：如何识别不同格式的可执行文件"><a href="#思考题5：如何识别不同格式的可执行文件" class="headerlink" title="思考题5：如何识别不同格式的可执行文件"></a>思考题5：如何识别不同格式的可执行文件</h2><ul><li>ELF文件头有魔数，可以用做识别文件格式。<h2 id="思考题6：冗余的属性"><a href="#思考题6：冗余的属性" class="headerlink" title="思考题6：冗余的属性"></a>思考题6：冗余的属性</h2></li><li>FileSiz表示程序头在文件中所占的大小，MemSiz表示程序头在内存中所占用的大小。</li></ul><h1 id="实验遇到的问题、思考、解决办法"><a href="#实验遇到的问题、思考、解决办法" class="headerlink" title="实验遇到的问题、思考、解决办法"></a>实验遇到的问题、思考、解决办法</h1><ul><li>对于必做任务三的FLOAT.c中的f2F函数实现曾出现过错误，然后修改过后仍hit bad trap，然后make clean之后再make run便可以运行。当时不知道make clean的原理，误以为f2F函数并没有错误，故又恢复原貌，导致提交的前一版stage2_finished不能通过integral.c测试。然后多次测试后发现FLOAT.c文件在修改后并不会重新编译，除非make clean。经助教齐学长讲解，明白了FLOAT.c生成的是动态链接库，不是可重定向目标文件，所以make clean之后才会重新编译。故最后修改正确之后补交了一版stage2_finished_new。  </li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>ELF头文件前几个数是为魔数（magic number），用做识别文件类型之用。</li><li>HIT BAD TRAP一般可能是三种错误，<ul><li>1.exec.c文件里opcode表填写错误，比如某条指令形式应为rm2r误写成r2rm；</li><li>2,.指令的具体实现出现错误，例如jcc系列指令的条件判断写错或者call、ret、push、pop、leave等指令的ebp、esp寄存器相关内容出错;</li><li>3.FLOAT函数具体实现出错。 </li></ul></li><li>需要写的程序不一定只在TODO标明的地方，其临近处或者其他地方也可能根据需要而添加或者修改代码  </li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA3 菜鸡记录</title>
    <link href="/2021/09/28/NEMU_PA3/"/>
    <url>/2021/09/28/NEMU_PA3/</url>
    
    <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<del>端地一番折磨</del>  </p><p>本篇博客由PA3实验报告改编而来，后续可能会有必做题的过程<del>也可能没有</del>  </p><p> <del>看阿瓜的懒惰程度了</del>  </p><h1 id="实验进度表"><a href="#实验进度表" class="headerlink" title="实验进度表"></a><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>实现一级Cache</td><td>已完成</td></tr><tr><td>必做任务2</td><td>在NEMU中实现分段机制</td><td>已完成</td></tr><tr><td>必做任务3</td><td>在NEMU中实现分页机制</td><td>已完成</td></tr><tr><td>必做任务4</td><td>实现TLB</td><td>已完成</td></tr><tr><td>选做任务1</td><td>实现二级Cache</td><td>已完成</td></tr><tr><td>选做任务2</td><td>建议调试器</td><td>未完成</td></tr><tr><td>选做任务3</td><td>为用户进程创建video memory 映射</td><td>未完成</td></tr></tbody></table><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a><strong>思考题</strong></h1><h2 id="思考题1：GDT能有多大"><a href="#思考题1：GDT能有多大" class="headerlink" title="思考题1：GDT能有多大"></a>思考题1：GDT能有多大</h2><ul><li>段选择符的结构中，INDEX有13位，故GDT最大能容纳2^13个段描述符  </li></ul><h2 id="思考题2：为什么是线性地址"><a href="#思考题2：为什么是线性地址" class="headerlink" title="思考题2：为什么是线性地址"></a>思考题2：为什么是线性地址</h2><ul><li>不可以。虚拟地址需要经GDT中的段表翻译才能得出地址，而如果GDTR中存放虚拟地址则找不到GDT在哪里了。  </li></ul><h2 id="思考题3：如何提高寻找段描述符的效率"><a href="#思考题3：如何提高寻找段描述符的效率" class="headerlink" title="思考题3：如何提高寻找段描述符的效率"></a>思考题3：如何提高寻找段描述符的效率</h2><ul><li>可以按照高速缓存的思想，建立类似cache 和 TLB 的结构来提高寻找效率。  </li></ul><h2 id="思考题4：段式存储管理的缺点"><a href="#思考题4：段式存储管理的缺点" class="headerlink" title="思考题4：段式存储管理的缺点"></a>思考题4：段式存储管理的缺点</h2><ul><li>分段管理要求分配一大段连续的存储空间，难以实现并且容易造成大量的外部碎片出现。  </li></ul><h2 id="思考题5：页式存储管理的优点"><a href="#思考题5：页式存储管理的优点" class="headerlink" title="思考题5：页式存储管理的优点"></a>思考题5：页式存储管理的优点</h2><ul><li>没有外部碎片，并且不再需要大段连续的存储空间，提高了内存的利用率。  </li></ul><h2 id="思考题6：一些问题"><a href="#思考题6：一些问题" class="headerlink" title="思考题6：一些问题"></a>思考题6：一些问题</h2><ol><li><ul><li>Q：为什么页表表项中的基地址信息只有20位而不是32位</li><li>A：分页基地址有20位是8086的传统<br>  在8086的分段机制中，每个段的基地址由seg_reg（即段寄存器的值）&lt;&lt;4得到，而段寄存器是16位的，左移4位得到20位的基地址。  </li></ul></li><li><ul><li>Q：表项和CR3中的基地址都是物理地址，这是必须的吗？能否采用虚拟地址或者线性地址？  </li><li>A：是必须的，如果cr3中的基地址是虚拟地址，则无从寻找页表翻译成物理地址，进入鸡生蛋蛋生鸡的死循环。至于其他表项的虚拟地址与线性地址问题同理。</li></ul></li><li><ul><li>Q：为什么不采用一级页表？采用一级页表会有什么缺点？  </li><li>A：多级页表可以有效地节约内存空间，如果仅采用一级页表，将可能导致较大的页表长期驻留在内存中。  </li></ul></li></ol><h2 id="思考题7：空指针是“空”的吗"><a href="#思考题7：空指针是“空”的吗" class="headerlink" title="思考题7：空指针是“空”的吗"></a>思考题7：空指针是“空”的吗</h2><ul><li>空指针只是未分配或者未指向内存任何位置的指针，并不是“NULL”的。</li></ul><h2 id="思考题8：在扁平模式下如何进行保护"><a href="#思考题8：在扁平模式下如何进行保护" class="headerlink" title="思考题8：在扁平模式下如何进行保护"></a>思考题8：在扁平模式下如何进行保护</h2><ul><li>对于数据有不同的访问权限，未达到需要的权限时不能进行写操作。  </li></ul><h2 id="思考题9：地址映射"><a href="#思考题9：地址映射" class="headerlink" title="思考题9：地址映射"></a>思考题9：地址映射</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/%E6%80%9D%E8%80%83%E9%A2%989.png" alt="思考题9" title="思考题9">  </p><h2 id="思考题10："><a href="#思考题10：" class="headerlink" title="思考题10："></a>思考题10：</h2><ul><li>pframe_addr是无符号类型，它的值永远大于等于0，所以for循环无法退出，出现错误。 </li></ul><h2 id="思考题11：分页机制"><a href="#思考题11：分页机制" class="headerlink" title="思考题11：分页机制"></a>思考题11：分页机制</h2><ol><li><ul><li>因为这里定义的ｘ生成的地址是虚拟地址，超过了物理地址的界限，报错0xc014a000 outside of the physical memory。<br>而ｋvm.c 中的虚拟地址都经过了 va_to_pa 的转换，在物理地址范围之内。  </li></ul></li><li><ul><li>进行反汇编后，其地址如下：<br>c01003d6:    e8 65 09 00 00           call   c0100d40<init_page>   该call指令的opcode为e8，实现的是跳转到：该条指令的下一条指令的首地址+偏移量的位置。由于未进行寻址，故不需要进行虚实地址转化。</li></ul></li><li><ul><li>分页的环境下，在没有初始化页表时，0～128M的虚拟地址到物理地址的映射相当于一个简易的页表，使得高位的地址可以通过该虚拟地址（即经过va_to_pa）访问到物理地址，从而进行初始化页表的操作。  </li></ul></li><li><ul><li>init_mm()函数执行退出时。该函数将nemu映射到了高位地址并且将之前的PDE全部置为无效，此时返回main.c时，栈中保存的返回地址需要经过虚实转换，可由于页面被置为了无效，所以报错。  </li></ul></li><li><ul><li>查看汇编代码，直接调用此函数时，nemu运行在物理地址上，由于在init_mm中将之前的PDE都置为无效，所以在loader()函数寻址时页面无效，导致报错。 </li></ul></li></ol><h1 id="实验遇到的问题、思考、解决办法"><a href="#实验遇到的问题、思考、解决办法" class="headerlink" title="实验遇到的问题、思考、解决办法"></a>实验遇到的问题、思考、解决办法</h1><ul><li><p>对GDT一直看不很明白，以为数组的元素大小也需要跟处理器位数一样，最大是32位，实际上GDT的元素就是64位的段描述符，不过是分成了两个32位的结构体</p></li><li><p>由于初始时对分段很不理解，然后对指导书内容进行了相应的整理，如下：</p><ul><li><p>由于内存的增长，单纯段寄存器无法满足寻址需要，需要采用分段机制。  </p></li><li><p>80386作为32位处理器，故提供的指针都是32位的，而段寄存器只有16位，而段描述符有64位，用指针存储也无法做到。故采用GDT（Global Descriptor Table, 全局描述符表）来存储段描述符。  </p></li><li><p>GDT是一个数组，数组元素是64位的段描述符（实际上是一个有两个32位member的结构体）而数组下标则由段寄存器的前13位得到（最后两位用来描述优先级，中间1位TI用来判断是GDT还是LDT）（GDT是全局描述符表，而LDT是每个进程的描述符表，由于分页机制的出现，LDT并不需要在NEMU中实现）  </p></li><li><p>CPU还需要记录GDT的基地址，这通过设置一个GDTR的寄存器来实现，该寄存器有48位，前32位类似于指针存放GDT的首地址，后16位记录GDT的长度  </p></li></ul></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>指针最大位数受CPU位数影响，所以才需要GDT进行段描述符的存储和读取</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA1 菜鸡记录</title>
    <link href="/2021/09/21/NEMU_PA1/"/>
    <url>/2021/09/21/NEMU_PA1/</url>
    
    <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<del>端地一番折磨</del>  </p><p>本篇博客由PA1实验报告改编而来，后续可能会有必做题的过程<del>也可能没有</del>  </p><p> <del>看阿瓜的懒惰程度了</del></p><h1 id="实验进度表"><a href="#实验进度表" class="headerlink" title="实验进度表"></a><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>实现正确的寄存器结构体</td><td>已完成</td></tr><tr><td>必做任务2</td><td>实现单步执行、打印寄存器、扫描内存</td><td>已完成</td></tr><tr><td>必做任务3</td><td>实现算术表达式的词法分析</td><td>已完成</td></tr><tr><td>必做任务4</td><td>实现算术表达式的递归求值</td><td>已完成</td></tr><tr><td>选做任务1</td><td>实现带有负数的算术表达式的求值</td><td>已完成</td></tr><tr><td>必做任务5</td><td>实现更复杂的表达式求值</td><td>已完成</td></tr><tr><td>选做任务2</td><td>实现指针解引用</td><td>已完成</td></tr><tr><td>必做任务6</td><td>实现监视点池的管理</td><td>已完成</td></tr><tr><td>必做任务7</td><td>实现监视点</td><td>已完成</td></tr></tbody></table><h1 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a><strong>必做题</strong></h1><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a><strong>思考题</strong></h1><h2 id="思考题1-：opcode-table数组的类型"><a href="#思考题1-：opcode-table数组的类型" class="headerlink" title="思考题1 ：opcode_table数组的类型"></a>思考题1 ：opcode_table数组的类型</h2><ul><li>opcode_table为helper_fun类型的数组，而helper_fun类型为指向参数类型为swaddr_t且返回值类型为int的函数指针，故opcode_table为函数指针数组。  </li></ul><h2 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h2><h3 id="（1）要执行多久"><a href="#（1）要执行多久" class="headerlink" title="（1）要执行多久"></a>（1）要执行多久</h3><ul><li>cpu_exec函数的参数是uint32_t，即无符号整型，而传入的-1因会导致溢出而成为最大的无符号整型数，保证能够执行完输入的所有指令。  </li></ul><h3 id="（2）为什么要使用static"><a href="#（2）为什么要使用static" class="headerlink" title="（2）为什么要使用static"></a>（2）为什么要使用static</h3><ul><li><p>Q：框架代码中定义 wp_pool 等变量的时候使用了关键字 static，static 在此处的含义是什么? 为什么要在此处使用它?  </p></li><li><p>A： static表示wp_pool为静态全局变量，此处使用static是为了避免wp_pool在程序运行中被误修改。  </p></li></ul><h2 id="思考题3：读手册的方法"><a href="#思考题3：读手册的方法" class="headerlink" title="思考题3：读手册的方法"></a>思考题3：读手册的方法</h2><ol><li><ul><li>Q： EFLAGS 寄存器中的 CF 位是什么意思  </li><li>A: 在目录中检索register和flag发现2.3.4.1节和附录c有提及相关内容，查阅得：CF为进位标志，如果运算导致最高位产生进位或者借位则为1.否则为0。  </li></ul></li><li><ul><li>Q: ModR/M 字节是什么</li><li>A: 检索目录得ModR/M相关内容在17.2.1节，查阅可知ModR/M字节包括mod、reg、r/m三方面内容,分别表示索引类型或者寄存器编号、寻址模式编码等信息。  </li></ul></li><li><ul><li>Q: mov 指令的具体格式是怎么样的</li><li>A: 检索目录在12.2.2.11节内找到mov指令相关内容，查阅可知格式为DEST←SRC  </li></ul></li><li><ul><li>shell命令:<br>  find . -name “*[.h|.cpp]” | xargs wc -l<br>  使用上述命令，得代码共129281行    </li></ul></li><li><ul><li><p>Make文件：  </p><p>  -Wall 使GCC产生尽可能多的警告信息，取消编译操作，打印出编译时所有错误或警告信息。  </p><p>  -Werror 要求GCC将所有的警告当成错误进行处理，从而终止编译操作。  </p><p>  使用-Wall和-Werror就是为了找出所有存在的或者潜在的错误，优化程序。</p></li></ul></li></ol><h1 id="实验遇到的问题、思考、解决办法"><a href="#实验遇到的问题、思考、解决办法" class="headerlink" title="实验遇到的问题、思考、解决办法"></a>实验遇到的问题、思考、解决办法</h1><ul><li><p>在刚开始实验的时候，遇到“Makefile : “run”……”这种错误会不知所措，Prof Wei指点我要慢慢debug，通过Log、Assert等函数以及GDB等工具，最终解决了bug。<del>（GDB过于生疏，PA1完全靠肉眼debug）</del>  </p></li><li><p>某次在虚仿平台关机导致git文件损坏，csdn、stackoverflow搜索到的办法都未能解决问题，最终在Wei老师的帮助下通过删除然后重新绑定远程仓库解决了问题。  </p></li><li><p>打印寄存器时起初不知道如何依次打印，后来发现reg.h文件下有定义好的regsl数组和reg_l函数可以利用。  </p></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li><p> 要细读实验指导书，里面内容很详细，开始时候因为只看PPT导致忽略掉了很多细节内容。</p></li><li><p>调试程序时要善于使用gdb等工具，小型的bug可以使用Log、Assert等函数两面夹击来判断bug出现在哪里，总之对bug不要失措.</p></li><li><p>对于某任务中所用到的文件中的代码要通读一下，不求全看懂，多少知道相关函数、数组是做什么的，比如reg.h文件下的regsl数组和reg_l函数，</p></li><li><p>在.c文件中声明函数后要在.h文件中定义</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/21/hello-world/"/>
    <url>/2021/09/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>The First One</title>
    <link href="/2021/07/03/The-First-One/"/>
    <url>/2021/07/03/The-First-One/</url>
    
    <content type="html"><![CDATA[<p>这是王珣的第一篇博客，自然要题写几个大字</p><p>hello, world!  </p><p><img src="https://raw.githubusercontent.com/zcsryu2/BlogImages/main/hello_world_movie.jpg" alt="这是图片" title="hello world"><br>（划掉）</p><p><img src="https://raw.githubusercontent.com/zcsryu2/BlogImages/main/hello_world.jpg" alt="这是图片" title="hello, world"></p><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲话</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
